# DECISIONS.md
**Проект:** «Континуум» закрытая платформа обучения (Teachers + Students)  
**Назначение:** Decision Cards (архитектурные фиксации) — что выбрали и почему.  
**Формат:** DEC-XX, статус, контекст, решение, последствия.  

---

## DEC-01 — Архитектурный стиль: Modular Monolith + отдельный worker
**Статус:** Accepted  
**Контекст:** Нужны чёткие доменные границы (DDD), но при этом быстрый MVP. Есть тяжёлая асинхронная компиляция LaTeX.  
**Решение:**  
- Backend = **NestJS Modular Monolith** (BC по модулям).  
- Отдельный процесс **worker** (BullMQ consumers) для `render` и `batch` задач.  
**Последствия:**  
- Простая эксплуатация (1 API сервис + 1 worker).  
- Границы BC остаются внутри репозитория и кода (port/adapter).  
- Рендер не блокирует API.

---

## DEC-02 — Технологический стек (backend/frontend/storage)
**Статус:** Accepted  
**Контекст:** Требование: NestJS, Next.js, ReactFlow, CodeMirror6, S3-compatible.  
**Решение:**  
- Backend: NestJS + PostgreSQL + Prisma  
- Frontend: Next.js (latest stable) + React (latest stable)  
- Queue: Redis + BullMQ  
- Storage: S3-compatible (MinIO dev)  
- PDF view: PDF.js (без браузерного viewer UI)  
**Последствия:**  
- Быстрый dev и предсказуемые миграции.  
- Удержание зависимостей в “latest stable” требует регулярных обновлений и CI security gates.

---

## DEC-03 — Политика безопасности зависимостей (React/Next из-за CVE-2025-55182)
**Статус:** Accepted  
**Контекст:** Уязвимость в RSC (в т.ч. CVE-2025-55182) требует избегать старых версий.  
**Решение:**  
- **React и Next.js держим на latest stable**.  
- В CI включаем dependency scanning и блокируем merge при critical/high.  
**Последствия:**  
- Нужны регулярные обновления и контроль регрессий.  
- Стабильность обеспечивается lockfile и контролируемыми PR.

---

## DEC-04 — Публикация и видимость: иерархическое скрытие + unpublish пересчитывает статистику
**Статус:** Accepted  
**Контекст:** Пользовательское правило: если родитель draft → всё скрыто; unpublish = “объекта нет и он не учитывается”.  
**Решение:**  
- Видимость для ученика: объект виден только если он `published` и все родители `published`.  
- При `unpublish` запускаем batch job пересчёта прогресса/availability и пересчитываем `total_tasks`, проценты и статусы.  
**Последствия:**  
- Усложнение пересчётов при массовых изменениях, решаем batch jobs.  
- История Attempts и Audit сохраняется (не удаляем).

---

## DEC-05 — Две метрики прогресса (completion vs solved)
**Статус:** Accepted  
**Контекст:** В требованиях две метрики с разной семантикой.  
**Решение:**  
- **Unit Completion %**: `counted_tasks / total_tasks`, counted = `correct | credited_without_progress | teacher_credited`.  
- **Task Solved %**: `solved_tasks / total_tasks`, solved = `correct | accepted_photo | teacher_credited`.  
**Последствия:**  
- В БД храним и counters, и percents (кэшируем), пересчитываем детерминированно.  
- UI должен показывать обе метрики и не смешивать их.

---

## DEC-06 — Required задачи как жёсткий гейт + required_skipped флаг
**Статус:** Accepted  
**Контекст:** Required задачи должны блокировать unlock, но могут быть auto-credited после 6 ошибок. Нужно отдельное отображение “важная задача не решена”.  
**Решение:**  
- required задачи обязательны для “unit eligible”: либо solved/accepted, либо `credited_without_progress`.  
- Если required ушла в auto-credit → ставим `required_skipped=true` (в student_task_state) + уведомление учителю.  
**Последствия:**  
- Учителю проще видеть “слабые места”.  
- Unlock возможен, но видно что required пропущена.

---

## DEC-07 — Попытки 3+3: блокировка после 3, закрытие после 6
**Статус:** Accepted  
**Контекст:** Строгая механика мотивации/дисциплины + прозрачность прогресса.  
**Решение:**  
- После 3-й неверной попытки: блокировка на `X минут` (X на уровне курса).  
- После 6-й: `credited_without_progress`, показываем ответ/решение, дальше попыток нет (кроме действий учителя).  
- Попытка **не создаётся**, если задача заблокирована (`locked_until > now`).  
**Последствия:**  
- Честная статистика попыток (без “спама” во время блока).  
- UI показывает оставшееся время блокировки.

---

## DEC-08 — Ревизии задач: любая правка = новая ревизия; зачёт не отменяется
**Статус:** Accepted  
**Контекст:** Требование консистентности: “если засчитано — остаётся засчитанным”, но попытки/блокировки относятся к актуальной ревизии.  
**Решение:**  
- Любое изменение задачи создаёт `task_revision` и делает её активной.  
- Если задача уже засчитана студенту (любой credited статус) — она остаётся засчитанной.  
- Счётчики ошибок/блокировок ведутся по `student_task_state.active_revision_id`.  
**Последствия:**  
- В `student_task_state` храним `credited_revision_id` и `active_revision_id`.  
- При переходе на новую активную ревизию для не-зачтённых учеников — сбрасываем/ведём счётчики по новой ревизии.

---

## DEC-09 — Фото-задачи: только ведущий учитель; rejected не увеличивает ошибки; пересдачи безлимитны
**Статус:** Accepted  
**Контекст:** Фото-ответы требуют ручной проверки и отдельной логики.  
**Решение:**  
- Фото Attempt → `pending_review`.  
- Проверяет только `lead_teacher_id` ученика.  
- `rejected` не увеличивает ошибки/блокировки, пересдачи безлимитны.  
- `accepted` увеличивает solved и completion.  
**Последствия:**  
- Нужна очередь проверок и строгая проверка прав.  
- Нужны события и уведомления по решениям review.

---

## DEC-10 — Unlock rules: AND по prereq; граф не пересекает разделы
**Статус:** Accepted  
**Контекст:** Граф юнитов в пределах раздела; зависимости многовходовые.  
**Решение:**  
- Unlock `available` если **все prereq** юниты “eligible” (completed по правилам) и нет незачтённых required/pending.  
- Граф хранится на уровне section (`unit_graph_edges`).  
**Последствия:**  
- Пересчёт availability идёт по section-графу.  
- Изменение графа требует batch recompute.

---

## DEC-11 — Пересчёт availability/progress: синхронно на попытках, batch на publish/unpublish и graph-update
**Статус:** Accepted  
**Контекст:** Нужен мгновенный UX ученика, но publish/unpublish и массовые изменения должны быть безопасны.  
**Решение:**  
- Attempt/PhotoAccepted/TeacherCredit/Override → синхронно и инкрементально.  
- Publish/Unpublish/GraphUpdate → batch jobs с пересчётом по затронутым ученикам.  
- `UnitBecameAvailableForStudent` логируем как “reach”.  
**Последствия:**  
- 2 очереди: `render`, `batch`.  
- Нужны idempotent batch handlers и защитные лимиты.

---

## DEC-12 — Отображение PDF “как контент страницы”: PDF.js без браузерного viewer UI
**Статус:** Accepted  
**Контекст:** Требование: без рамок/тулбаров/iframe; адаптивно; лениво.  
**Решение:**  
- PDF.js (`pdfjs-dist`) с собственным viewer-компонентом на фронте.  
**Последствия:**  
- Нужно аккуратно управлять производительностью (lazy pages, кеширование).  
- Нужен endpoint выдачи signed URL на PDF.

---

## DEC-13 — Files/Assets как отдельный модуль для переиспользования кода
**Статус:** Accepted  
**Контекст:** Файлы используются в разных местах: attachments, фото, pdf теории/решений.  
**Решение:**  
- Выделяем BC5 Files & Assets:
  - upload session, finalize upload
  - entity_assets связь
  - download signed URLs с ACL
**Последствия:**  
- Единый контроль доступа к файлам.  
- Чёткая точка расширения под будущие типы ассетов.

---

## DEC-14 — Audit log: логируем и admin, и learning события с фильтрацией по категориям
**Статус:** Accepted  
**Контекст:** Требование хранить журнал событий для админ-действий и учебных событий.  
**Решение:**  
- `domain_event_log` хранит все события с `category` и фильтрами.  
**Последствия:**  
- Полезно для расследований/аналитики.  
- Нужно следить за объёмом и индексами, возможно архивирование позже.

---

## DEC-15 — Метрики должны быть расширяемыми
**Статус:** Accepted  
**Контекст:** Требование: “удобно добавлять новые метрики” по мере развития.  
**Решение:**  
- Analytics как отдельный BC с проекциями на доменных событиях.  
- Основные counters для MVP — в `student_unit_state`, остальные — в таблицах проекций/агрегатов (будущая работа).  
**Последствия:**  
- Новые метрики добавляются без изменения core домена (часто только новые проекции).  
- События должны быть стабильными и достаточно информативными.

---


## DEC-16 — Фиксация версий Node + pnpm (одинаковая среда у всех)
**Контекст**  
У нас monorepo (pnpm + turbo), часть сервисов в Docker, часть локально. Расхождение версий Node/pnpm приводит к “у меня работает”.

**Решение**  
Фиксируем единые версии среды:
- Node: **LTS** (выбираем и фиксируем в репо)
- pnpm: фиксируем через `packageManager` в root `package.json` (уже есть), и используем corepack.

**Обоснование**  
Это самый дешёвый способ убрать класс ошибок “несовместимые lockfile/peer deps/ESM”.

**Последствия**  
- Любой разработчик/CI поднимается с предсказуемыми версиями.
- Если обновляем Node/pnpm — делаем отдельным шагом и проверяем `pnpm smoke`.

**TODO (реализация в репо, когда решим применить)**  
- добавить заметку в `documents/DEVELOPMENT.md` “corepack enable”

---

## DEC-17 — Dev-режим Hybrid как стандарт
**Контекст**  
Web удобнее дебажить локально (Next dev server), но infra и backend-части должны быть воспроизводимы и одинаковы.

**Решение**  
Стандарт разработки:
- **Docker Compose**: infra + api + worker
- **Локально**: web

**Обоснование**  
Ускоряет UI итерации, но сохраняет воспроизводимость backend/infra.

**Последствия**  
- `pnpm dev:infra`, `pnpm dev:backend`, `pnpm dev:web`, `pnpm smoke` — обязательный путь.
- Порт-конфликты решаем стандартом: API 3000, WEB 3001.

---

## DEC-18 — Tectonic только в Worker-окружении, в sandbox, без shell-escape
**Контекст**  
Rich LaTeX компилируется на сервере, потенциально небезопасен (инъекции, доступ к FS/сети). Компиляция должна быть асинхронной и не блокировать API.

**Решение**  
- Компиляция **только** в отдельном воркере (render worker), **не в API**.
- Воркеры для рендера запускаются в изолированной среде (контейнер), без привилегий.
- Отключаем/не используем опасные режимы (в частности, **никакого shell-escape**).
- Артефакты: PDF → S3; логи ошибок → БД.

**Обоснование**  
Разделение обязанностей и blast-radius: API остаётся быстрым и безопасным, тяжёлый/опасный процесс живёт отдельно.

**Последствия**  
- Любой endpoint “Preview/Compile” в UI становится постановкой job.
- Ошибки компиляции возвращаются через статус job, а не синхронный ответ API.

**Вне scope этого DEC**  
Реализация конкретного render job / pdf-view — будет в vertical slice, где потребуется.

---

## DEC-19 — Политика секретов: только `.env.example` в репо, `.env` никогда
**Контекст**  
У нас есть MinIO creds, DB creds, потенциально ключи подписи/TTL для signed URLs.

**Решение**  
- В репозитории хранится **только** `.env.example`.
- Реальные `.env`/секреты — локально или в CI secrets, никогда в git.
- Любые новые env-переменные добавляем сначала в `.env.example` и описываем в `documents/DEVELOPMENT.md`.

**Обоснование**  
Это базовая дисциплина безопасности и воспроизводимости.

**Последствия**  
- Любая новая конфигурация проходит через явный контракт окружения.
- Утечек в git меньше по определению.

---

## DEC-20 — Smoke-check как “контроль качества окружения” перед любыми фичами
**Контекст**  
Мы развиваем систему пошагово, хотим ловить регрессии сразу.

**Решение**  
- Любая “инфра/настройка/библиотеки” меняется только вместе с проверкой `pnpm smoke`.
- `pnpm smoke` — минимальный end-to-end контроль (health/ready/enqueue/web debug).

**Обоснование**  
Это обеспечивает контролируемость и снижает стоимость ошибок.

**Последствия**  
- Любая поломка окружения выявляется в течение минут.
- На CI (когда подключим) smoke станет базовой проверкой.

---


## Mini-gap-check (что ещё может потребовать DEC позже)
1) JWT vs server-side sessions (если ещё не зафиксировали отдельной DEC).
2) Политика удаления/архивации ассетов и событий (ретеншн).
3) Политика восстановления после backup (RPO/RTO) — infra DEC.